信号量的初始化为
int sem_init(sem_t *sem, int pshared, unsigned value);
sem:信号量指针
pashared:是否在进程间共享的，０为不共享，１为共享．
value:信号量的初始值(有人来用--，有人还++)
调用sem_post()一次信号量作加１操作
sem_wait()减１
信号量值大于或等于0时，阻塞的线程才能继续运行

利用线程信号量实现线程互斥
这个初值要设置为I(1)
读者＿写者问题
原语---pv操作
p操作　　减
v操作　　加
sem_post()   加1操作  ===> V(1)
sem_wait()   减1操作  ===> P(1)

利用线程信号量实现线程同步
这个初值要设置I(0)
一个线程负责计算t1＿＿＿＿＿＿＿＿＿＿＿＿＿＿一个线程负责获取结果t2
　　　　　　　　　　　　　　　　　　　　　　　　　t2先做等待P操作
计算并将结果放置　　　　　　　　　　　　　　　　从临界资源中获取　　
在临界资源　　　　　　　　　　　　　　　　　　　　结果
t1做V操作

线程死锁：
１．两个线程试图同时占用两个资源，并按不同的次序锁定相应的共享资源．
解决方法：
１．按相同的次序锁定相应的共享资源
２．使用函数pthread_mutex_trylock(), 它是函数pthread_mutex_lock()的非阻塞函数．
