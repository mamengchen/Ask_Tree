信号量的初始化为
int sem_init(sem_t *sem, int pshared, unsigned value);
sem:信号量指针
pashared:是否在进程间共享的，０为不共享，１为共享．
value:信号量的初始值(有人来用--，有人还++)
调用sem_post()一次信号量作加１操作
sem_wait()减１
信号量值大于或等于0时，阻塞的线程才能继续运行

利用线程信号量实现线程互斥
这个初值要设置为I(1)
读者＿写者问题
原语---pv操作
p操作　　减
v操作　　加
sem_post()   加1操作  ===> V(1)
sem_wait()   减1操作  ===> P(1)

利用线程信号量实现线程同步
这个初值要设置I(0)
一个线程负责计算t1＿＿＿＿＿＿＿＿＿＿＿＿＿＿一个线程负责获取结果t2
　　　　　　　　　　　　　　　　　　　　　　　　　t2先做等待P操作
计算并将结果放置　　　　　　　　　　　　　　　　从临界资源中获取　　
在临界资源　　　　　　　　　　　　　　　　　　　　结果
t1做V操作

线程死锁：
１．两个线程试图同时占用两个资源，并按不同的次序锁定相应的共享资源．
（通俗来说，就是两把锁，两个线程都想去获取两把锁但是都只是各自获得一把，但是都在等对方释放锁）

产生死锁的４个必要条件：
１．互斥条件：一个资源每次只能被一个进程使用．
２．请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
３．不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺．
４．循环等待条件：若干进程之间形成一种头尾相连的循环等待资源关系．

解决方法：
１．按相同的次序锁定相应的共享资源．（避免出现循环）
２．避免事务中的用户交互．（减少持有资源的时间，减少锁竞争）
３．使用函数pthread_mutex_trylock(), 它是函数pthread_mutex_lock()的非阻塞函数．

线程和信号
进程中每个线程都有自己的信号屏蔽字和信号未决字
信号的处理方式是进程中所有线程共享的
进程中的信号是递送到单个线程的(进程有多个线程，信号只是发送给其中一个)
定时器是进程资源，进程中所有的线程共享相同的定时器．
    子线程调用alarm()函数产生的alarm信号发送给主控线程．
int pthread_sigmask(功能：线程的信号屏蔽＞＞返回值：成功返回０，出错返回错误编号)
